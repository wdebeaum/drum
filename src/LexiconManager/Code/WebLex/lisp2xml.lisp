;;;; The intent of this code is not to make a one-to-one correspondence between
;;;; lisp expressions and XML. It is merely to generate XML easily from a
;;;; subset of lisp expressions.
;;;; <tag attribute="value">...</tag>
;;;; may be generated by
;;;; (convert-lisp-to-xml '(tag :attribute value ...))
;;;; If a list has only attributes, it will generate a single <tag ... />

;; TODO indentation

(defun convert-lisp-to-xml (l)
  "returns a string of XML corresponding to the lisp structure l"
  (if (and (not (null l)) (listp l))
    (if (listp (car l))
      (concatenate 'string
        (convert-lisp-to-xml (car l))
        (if (not (null (cdr l)))
	  (convert-lisp-to-xml (mapcar #'list (cdr l)))
	  ""
	  )
	)
      ; not listp car l
      (concatenate 'string
	(format nil "<~a" (car l))
	(let* ((remainder (convert-attributes (cdr l)))
	       (len (length remainder))
	       )
	  (if (string= (subseq remainder (- len 2) len) "</")
	    (concatenate 'string remainder (format nil "~a>~%" (car l)))
	    remainder
	    )
	  )
	)
      )
    ; not a nonempty list
    (format nil "<~a />~%" l)
    )
  )

(defun convert-attributes (l)
  "converts :name value pairs to XML attributes until it encounters a non-keyword, then calls convert-lisp-to-xml on the rest of the list to get the XML contained by the current tag pair (<tag>...</tag>)."
  (if (null l)
    (format nil " />~%")
    (let ((name (car l))
          (value (cadr l))
	  (remainder (cddr l)))
      (if (keywordp name)
	(concatenate 'string
	  (string-downcase (format nil " ~a=\"~a\""
	                           (string name) (html-escape value)))
	  (convert-attributes remainder)
	  )
	(concatenate 'string
	  (format nil ">~%")
	  (convert-lisp-to-xml (mapcar #'list l))
	  "</"
	  )
	)
      )
    )
  )

(defun html-escape (input)
  "Converts input to a string with \", &, <, and > escaped to &quot;, &amp;, $lt;, and &gt;"
  (with-output-to-string (output)
    (loop for c across (format nil "~a" input)
          do (case c
	       (#\" (write-string "&quot;" output))
	       (#\& (write-string "&amp;" output))
	       (#\< (write-string "&lt;" output))
	       (#\> (write-string "&gt;" output))
	       (otherwise (write-char c output))
	       ))))

