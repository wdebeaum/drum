;; dynamic-lexicon.lisp
;;
;; Mary Swift
;;
;; Structures and functions used for dynamic word addition and deletion
;;
;; Dynamic words are added by request (e.g., webanalyzer in plow) and
;; stored in their own hash table *dynamic-lexicon-word-table* until
;; system is reset or reloaded. If the dynamic lexicon is in use any
;; lexicon retrieval operation for the parser (retrieve-from-lex)
;; checks not only the core lexicon but also the dynamic lexicon
;;

(in-package "LEXICONMANAGER")

(defvar *dynamic-lexicon-word-table* nil) ;; hash table for dynamically added words only
;; moving this defvar to lexicon-functions.lisp to avoid warnings
; (defvar *use-dynamic-lexicon* nil) ;; t if dynamic lexicon is in use

(defun init-dynamic-lexicon ()
  "initialize the dynamic lexicon"
   (setq *dynamic-lexicon-word-table* (make-hash-table))
   (setq *use-dynamic-lexicon* t)
  )

(defun reinit-dynamic-lexicon ()
  "clear dynamic lexicon hash table -- this is called whenever LxM gets a start-conversation (on system reset)"
   (if (hash-table-p *dynamic-lexicon-word-table*) ;; on system startup this var is nil
       (clrhash *dynamic-lexicon-word-table*))
   (setq *use-dynamic-lexicon* nil)
  )

(defun in-lexicon (lexeme pos lftype)
;;
;; check if lexeme is already defined in the lexicon with the given pos and lftype
;; NB templates are not currently compared -- for completeness this should be done but in the
;; existing implementation the only dynamic words added are w::name, lf::text-representation and w::name-templ
;;
;; lexeme  : lexeme (already in w:: package) -- multi-word expressions are lists
;;           e.g. (your account), books
;; pos     : e.g. w::name, w::n, w::v
;; lftype  : semantic type in the lf ontology, e.g. lf::text-representation
;; template: name of the linking template, e.g. name-templ  
;; returns : t if lexeme is defined in the lexicon with the given pos and lftype, otherwise nil
;;
  (let ((res nil))
    (mapcar (lambda (def)
	    (let* ((attributes (lex-entry-feats def))
		   (this-pos (lex-entry-cat def))
		   (this-lftype  (strip-out-lf (get-feature-values attributes 'w::lf)))
		   (these-words (lex-entry-words def))
		   )
	      ;; only check definitions for the given pos and lf
	      (when (and (eq this-pos pos) (eq this-lftype lftype))
		(cond ((listp lexeme)
		       ;; check multi-word expression equivalence
		       (if (and (>= (length lexeme) 2) (equal these-words lexeme))
			   (setq res t)))			
			((symbolp lexeme)
			 (if (= (length these-words) 1) (setq res t)))
			 (t nil)))))
	    (if (listp lexeme) (retrieve-from-lex (car lexeme))
	      (retrieve-from-lex lexeme)))
    res)
)

(defun write-lex-data-file (word cat type templ)
  (let* ((string-word (string-downcase (string-left-trim "w::" word))) ;;remove package and convert to string for fname
	 ;(p #!TRIPS"src/LexiconManager/Data/new/")
	 (fname (concatenate 'string "dll-" string-word ".lisp")) ; signifies file generated by dynamic lexicon learning
	 ;(fullname (make-pathname :directory (pathname-directory p)
	;		       :name fname
	;		       :type "lisp"
	;		       ))
	 (out (open  fname
		     :direction :output
		     :if-exists :supersede ;; update to append new information
		     :if-does-not-exist :create))
	)
    (format out ";;;; Dynamically generated lexical data file for word ~S ~%~%" word)
    (format out "(define-words :pos ~S :templ  ~S ~%" cat templ)
    (format out ":tags (:dynamic) ~%:words ( ~%")
    (format out "(~S~% (SENSES~% ((LF-PARENT  ~S))))))~%" word type)
    (finish-output out)
    (lexiconmanager-warn "word dynamically added to hash table -- generating lexicon data file ~S~%" fname)
    )
  )



;;------------------------
;; 
;; functions to add words to the dynamic lexicon hash table -- called from add-names
;;

(defun dynamic-add-entry (entry)
  "add a vocabulary entry to the dynamic lexicon table"
  ;; assume no morphological variants for dynamic words; they are just added 'as is'
  (push (list :none 
	      (gen-id (vocabulary-entry-word entry))
	      entry)
	(gethash (vocabulary-entry-word entry) *dynamic-lexicon-word-table*))
  )

(defun dynamic-define-word (e pos templ boost-word)
  "use parameters to define a word as a vocabulary entry structure and add it to the dynamic lexicon table"
  (let ((entry (parse-vocab-table-entry e :pos pos :default-template templ :boost-word boost-word)))
        (if (vocabulary-entry-p entry)
          (dynamic-add-entry entry))
	)
  )

(defun dynamic-add-lexeme (words pos lf template)
 ; dynamic-add-lexeme (words pos lf template)
;;
;; words   : list of lexemes to be added -- multi-word expressions are embedded in lists
;;           e.g. ((your store) books (your account) cart (wish list) (under fifty dollars) (baby zero to two))
;; pos     : part of speech, e.g. w::n, w::name (web links are added as names)
;; lf      : lf type, e.g. lf::icon for web links
;; template: template for this lexeme, e.g. name-templ  
;; returns : success if any lexeme is successfully added; also success if lexemes are already in lexicon; otherwise failure
;; 
    "Add new lexemes to the *lexicon-data* table dynamically, ie, based on a message to the LxM after the lexicon data files are already loaded.
"
    ;; initialize the dynamic lexicon hash table if necessary
    (if *use-dynamic-lexicon* nil
      (init-dynamic-lexicon))
;; for every lexeme in the list of words, make sure it's in the w:: package, create an entry and add it to the lexicon    
    (let ((res '(failure))
	  ;; make sure everything is in the right package
	  (this-pos (util::convert-to-package pos 'w))
	  (this-lf (util::convert-to-package lf 'ont))
	  (this-template (util::convert-to-package template 'lxm))
	  )   
      (dolist (lexeme words)
	(let* ((new-lexeme (if lexeme (util::convert-to-package lexeme 'w)))
	       ;; create the word entry with the sense; other slots filled in by define-a-word
	       ;; entry format is:  (w::word (SENSES ((LF-PARENT LF::LF))))
	       (entry (list new-lexeme
			    (list 'senses
				  (list (list 'lf-parent this-lf)))))
	       )
	  ;; add the entry to the lexicon hash table if it's not already defined
	  (cond ((in-lexicon new-lexeme this-pos this-lf) 
		 (setq res '(failure)) ;; '(success) still success if already defined
		 (lexiconmanager-warn "word ~S already in lexicon! no word added~%" lexeme))
	    (t (when new-lexeme ;; not already in lexicon -- add it
		  ;;	(define-a-word entry this-pos this-template nil lxm::*lexicon-data*)
		  ;; define dynamic words in their own hash table
		  (dynamic-define-word entry this-pos this-template nil)
		  (if *write-dynamic-lexicon-file* (write-lex-data-file lexeme pos lf template))
		  (lexiconmanager-warn "word ~S as cat ~S type ~S dynamically added to lexicon. ~%" lexeme pos lf)
		  (setq res '(success))))
	    )
	  ))
      res)
    )

;;------------------------
;; 
;; functions to retrieve words from the dynamic lexicon hash table -- called from retrieve-from-lex
;;

(defun get-dynamic-vocab-entries (w)
  "returns vocabulary-entry structures stored in the dynamic word table"
  (mapcar (lambda (x)
	    (if (listp x)
		x
	      (list :none (gen-id w) x)))
	  (gethash w *dynamic-lexicon-word-table*)))


(defun get-dynamic-lex-entries (w)
  "returns lex-entry structures (needed by the parser, full semantic integration) generated from vocabulary-entry structures in the dynamic word table"
  (mapcan #'(lambda (e)		 
	      (mapcar #'(lambda (s)
			  (make-lexicon-entry w s))
		      (get-word-sense-definitions w e *lexicon-data*)))
	  (get-dynamic-vocab-entries w))
  )
