package TextTagger::Disambiguator;
require Exporter;
@ISA = qw(Exporter);
@EXPORT_OK = qw(disambiguate_sense_tags);

use KQML::KQML;
use TextTagger::Util qw(intersection union);
use TextTagger::Escape qw(escape_for_quotes);
use TextTagger::Tags2Trips qw(tags2trips trips2tagNative);

use strict vars;

sub disambiguate_sense_tags {
  my ($self, $text, @all_input_tags) = @_;
  # make sure we only send the interesting tags (sentence, pos, and sense with
  # lftype)
  my @input_tags = ();
  my %ambiguous_spans = ();
  for my $tag (@all_input_tags) {
    if ($tag->{type} eq 'sense' and exists($tag->{lftype})) {
      push @input_tags, $tag;
      push @{$ambiguous_spans{$tag->{start} . ' ' . $tag->{end}}}, $tag;
    } elsif ($tag->{type} eq 'sentence' or $tag->{type} eq 'pos') {
      push @input_tags, $tag;
    }
  }
  # delete unambiguous spans
  for (keys %ambiguous_spans) {
    delete $ambiguous_spans{$_} unless (@{$ambiguous_spans{$_}} > 1);
  }
  # send input tags (even unambiguous senses) to disambiguator module
  my $reply_content = $self->send_and_wait(
    ['request', ':content', ['disambiguate', ':text',
    '"' . escape_for_quotes($text) . '"',
    ':tags', KQML::KQMLAsString([tags2trips(\@input_tags, 'native')])
    ]]
  );
  # filter tags from disambiguator module
  my @output_tags = ();
  for my $reply_kqml (@$reply_content) {
    my $reply_tag = trips2tagNative($reply_kqml);
    my $span = $reply_tag->{start} . ' ' . $reply_tag->{end};
    next unless (exists($ambiguous_spans{$span})); # skip unambiguous senses
    # make sure types are upper case so they compare properly with those
    # generated by other taggers
    @{$reply_tag->{lftype}} = map { uc($_) } @{$reply_tag->{lftype}};
    my @proposed_tags =
      grep { @{intersection($_->{lftype}, $reply_tag->{lftype})} > 0 }
    	   @{$ambiguous_spans{$span}};
    next unless (@proposed_tags); # skip senses we didn't propose
    # add penn-pos from @proposed_tags to $reply_tag so that CombineTags works
    my $penn_pos;
    for my $proposed_tag (@proposed_tags) {
      if (exists($proposed_tag->{'penn-pos'})) {
	if (defined($penn_pos)) {
	  $penn_pos = union($penn_pos, $proposed_tag->{'penn-pos'});
	} else {
	  $penn_pos = [@{$proposed_tag->{'penn-pos'}}];
	}
      }
    }
    $reply_tag->{'penn-pos'} = $penn_pos if (defined($penn_pos));
    push @output_tags, $reply_tag;
  }
  return [@output_tags];
}

push @TextTagger::taggers, {
  name => "disambiguator",
  tag_function => \&disambiguate_sense_tags,
  output_types => ['sense'],
  input_text => 1,
  input_types => [qw(sentence pos)],
  optional_input_types => ['sense'] # not really optional, just avoiding a loop
};

1;

