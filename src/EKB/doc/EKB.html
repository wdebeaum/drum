<html><head><title>EKB</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.28,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sun Nov  4 03:05:27 2018 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u'
name="NAME"
>NAME</a></h1>

<p>EKB - Perl module for handling EKBs</p>

<h1><a class='u'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>OO interface:</p>

<pre>  use EKB;
  $ekb = EKB-&#62;new(); # creates new, empty EKB
  $ekb = EKB-&#62;new($filepath); # creates new EKB, read from file
  $ekb = EKB-&#62;new($string); # creates new EKB, read from string</pre>

<p>a. EKB operations</p>

<pre>  $ekb-&#62;print($filepath); # writes EKB to file
  $ekb-&#62;normalize(); # normalizes EKB
  $ekb-&#62;crop($uttnum); # crops EKB to content derived from a given utterance
  $ekb-&#62;save(); # saves EKB (writes it to the same file it was read from)</pre>

<p>b. Search</p>

<pre>  @list = $ekb-&#62;get_assertions(); # returns all assertions
  @list = $ekb-&#62;get_assertions(&#39;TERM&#39;); # returns all assertions of type TERM
  $a = $ekb-&#62;get_assertion(&#39;V123&#39;, &#39;EVENT&#39;); # returns assertion of type EVENT with id V123
  ...</pre>

<p>c. Editing</p>

<pre>  $a = $ekb-&#62;make_assertion($atype, $attributes, @properties);
  $ekb-&#62;add_assertion($a);
  $ekb-&#62;remove_assertion($a);
  $ekb-&#62;clean_assertion($a);
  $a1 = $ekb-&#62;clone_assertion($a);
  $a1 = $ekb-&#62;derive_assertion($a, $atype);
  $ekb-&#62;modify_assertion($a, $attributes, @properties);
  $ekb-&#62;add_arg($a, $role =&#62; $id);
  $ekb-&#62;add_feature($a, $feature =&#62; $value);
  $ekb-&#62;add_notfeature($a, $feature =&#62; $value);
  $ekb-&#62;make_complex_term($ids, $attributes, @properties);
  $ekb-&#62;make_conjoined_event($ids, $operator, $attributes, @properties);
  $ekb-&#62;make_aggregate_term($ids, $operator, $attributes, @properties);</pre>

<p>Non-OO utility functions:</p>

<pre>  $b = is_relation($a);
  $t = get_assertion_type($a);
  @args = assertion_args($a, $filter);
  @xargs = assertion_xargs($a);
  set_slot_value($n, $name, $value);
  $v = get_slot_value($n, $name);  
  $p = make_slot_node($pname =&#62; $pvalue);
  @plist = make_slot_nodes( $n1 =&#62; $v1, $n2 =&#62; $v2, ...);

  ...</pre>

<h1><a class='u'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>An EKB is an XML-based representation of events and concepts. EKBs are used in the TRIPS system to represent knowledge extracted from text.</p>

<p>This module offers an OO Perl representation of an EKB, with methods for manipulating it. Most methods operate on the XML document itself, and are based on <a href="http://search.cpan.org/perldoc?XML%3A%3ALibXML" class="podlinkpod"
>XML::LibXML</a>.</p>

<p>In short, an EKB is a set of assertions about the existence of certain entities and relations. The type of each assertion is represented via the tag of the XML element. Entities have the type <code>TERM</code>. Relations can represent events (type <code>EVENT</code>), causal connections (type <code>CC</code>), and two kinds of modality operators (types <code>MODALITY</code> and <code>EPI</code>) over relations.</p>

<p>Every assertion has a type, a set of attributes and a set of properties. Although logically there is no deep distinction between attributes and properties, by convention we represent as attributes those features of the assertion that don&#39;t have semantic content, and as properties those features that do have semantic content. Attributes are represented as XML attributes, and properties are represented as children elements. Properties themselves can have attributes.</p>

<p>NOTE: &#34;slot&#34; is another name for &#34;property&#34;</p>

<p>Typically, these assertions are extracted from text, in which case:</p>

<dl>
<dt><a 
>- the EKB includes a representation of the input text in two forms: as a collection of paragraphs, and as a collection of sentences.</a></dt>

<dd>
<dt><a 
>- the assertions include attributes pointing at the sentence, paragraph, and specific parts of the sentence from which the assertion was derived.</a></dt>
</dl>

<p>Thus, the EKB representation can serve as an annotation format.</p>

<p>For reasoning purposes, only the assertions are meaningful. An EKB representation can be derived directly from AKRL -- the KR representation language used in TRIPS -- in which case the EKB only contains assertions, suitable for reasoning. This functionality is used by some reasoners who understand the EKB representation but not the AKRL representation.</p>

<p>This package includes a number of helper functions that are not part of the OO representation. Most can be thought of as extensions of <a href="http://search.cpan.org/perldoc?XML%3A%3ALibXML" class="podlinkpod"
>XML::LibXML</a> for manipulating nodes with a certain kind of structure that are used often in EKBs.</p>

<h1><a class='u'
name="CONSTRUCTOR"
>CONSTRUCTOR</a></h1>

<h2><a class='u'
name="new(_$input,_@options_)"
>new( $input, @options )</a></h2>

<p>Creates a new EKB. All arguments are optional.</p>

<p>With no arguments, returns an empty EKB object (ie, one backed by an empty document).</p>

<p>If given, $input may be either a filename, or a string. The EKB returned is backed by the document resulting from parsing the XML off the file or the suring, respectively. On failure it returns <code>undef</code>.</p>

<p>A second argument may be provided, which can set various options.</p>

<p>TODO: describe options.</p>

<h1><a class='u'
name="GETTERS_AND_SETTERS"
>GETTERS AND SETTERS</a></h1>

<h2><a class='u'
name="get_file(_)"
>get_file( )</a></h2>

<p>Returns the file associated with this EKB.</p>

<h2><a class='u'
name="set_file(_$filepath_)"
>set_file( $filepath )</a></h2>

<p>Sets the file associated with this EKB.</p>

<p>This file must be set for <a href="#read(_)" class="podlinkpod"
>read()</a> and <a href="#save(_)" class="podlinkpod"
>save()</a> to work.</p>

<h2><a class='u'
name="get_document(_)"
>get_document( )</a></h2>

<p>Returns the XML document backing up this EKB.</p>

<h2><a class='u'
name="get_input(_)"
>get_input( )</a></h2>

<p>Returns the XML element containing the input data, if any.</p>

<h1><a class='u'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u'
name="init(_)"
>init( )</a></h2>

<p>Sets the EKB document to a new, empty EKB (one that contains only the root element, <code>&#60;ekb/&#62;</code>).</p>

<h2><a class='u'
name="read(_)"
>read( )</a></h2>

<p>Sets the document to one read from the EKB file.</p>

<p>As a side effect, if the EKB represents knowledge extracted from an article, as evidenced by the input document type, it tags all input paragraphs with the appropriate section type. NOTE: this feature should eventually be removed; instead, section types should be annotated during the creation of the source EKB.</p>

<h2><a class='u'
name="fromString(_$string_)"
>fromString( $string )</a></h2>

<p>Sets the document to one read from the given string.</p>

<h2><a class='u'
name="toString(_)"
>toString( )</a></h2>

<p>Returns a serialization of the EKB document root element as a string.</p>

<p>This is just a wrapper around the <code>toString</code> function in <a href="http://search.cpan.org/perldoc?XML%3A%3ALibXML%3A%3ANode" class="podlinkpod"
>XML::LibXML::Node</a>.</p>

<p>Caveat emptor: This method produces a serialization of the &#34;ekb&#34; root node, not of the document itself, therefore there will be no XML declaration.</p>

<h2><a class='u'
name="print(_$filepath_)"
>print( $filepath )</a></h2>

<p>Prints the EKB to a file with the given file name. The EKB is formated and indented using xmllint. Generates a fatal error in case of failure.</p>

<p>If the argument is missing, the output goes to STDOUT.</p>

<h2><a class='u'
name="save(_)"
>save( )</a></h2>

<p>Saves the EKB to the EKB file. Generates an error if the EKB file is not set.</p>

<h2><a class='u'
name="fix(_)"
>fix( )</a></h2>

<p>Upgrades older EKB formats to the current format. Limited capabilities.</p>

<h2><a class='u'
name="normalize(_$opts_)"
>normalize( $opts )</a></h2>

<p>Normalizes the EKB. Specifically, it modifies the EKB so that:</p>

<dl>
<dt><a name="-_uttnums_start_at_1;"
>- uttnums start at 1;</a></dt>

<dd>
<dt><a name="-_lisp_code_is_removed,_unless_given_the_option_{keep_lisp_=&#62;_1}_;"
>- lisp code is removed, unless given the option {keep_lisp =&#62; 1} ;</a></dt>

<dd>
<dt><a name="-_duplicative_information_is_removed_from_event_arguments."
>- duplicative information is removed from event arguments.</a></dt>

<dd>
<dt><a name="-_arg#_child_elements_are_renamed_to_arg_child_elements."
>- arg# child elements are renamed to arg child elements.</a></dt>
</dl>

<p>It also calls See: <a>fix()</a> to fix formatting issues.</p>

<h2><a class='u'
name="crop(_$sid_)"
>crop( $sid )</a></h2>

<p>Removes all input and assertion elements except those for the utterance with the uttnum $sid.</p>

<p>This method will reduce the paragraph to just the desired sentence. As of this version, sentences don&#39;t have frame numbers to identify precisely the region in the paragraph from which they are derived. Therefore, cropping the paragraph to the desired sentence is heuristic. However, to ensure that the result is valid, there are some fairly strict checks. If anything is amiss, it will fail rather than produce an invalid EKB. For example, EKBs derived from XML inputs are likely to fail.</p>

<h2><a class='u'
name="filter(_$options_)"
>filter( $options )</a></h2>

<p>Generic filter for removing parts of the input and related assertions.</p>

<p>$options is a reference to a hash. The only keys handled are <code>documents</code>, <code>paragraphs</code> and <code>sentences</code>. The value for each such key is a reference to a list of appropriate IDs. The result of the filter is such that only the document/paragraphs/sentences indicated are kept.</p>

<p>Caveats:</p>

<dl>
<dt><a name="1)_Unlike_crop(),_this_method_does_not_attempt_to_keep_frame_numbers_valid_after_paragraphs_are_removed."
>1) Unlike crop(), this method does not attempt to keep frame numbers valid after paragraphs are removed.</a></dt>

<dd>
<dt><a 
>2) Using multiple keys simultaneously that are not consistent with each other may not work as expected, so we discourge such use!</a></dt>
</dl>

<h2><a class='u'
name="remove_doc(_$docid_)"
>remove_doc( $docid )</a></h2>

<p>Removes the document with the id $docid, all its paragraphs and sentences, and all the assertions derived from it.</p>

<h2><a class='u'
name="remove_paragraph(_$pid_)"
>remove_paragraph( $pid )</a></h2>

<p>Removes the paragraph with the id $pid, all its sentences and all assertions derived from it.</p>

<h2><a class='u'
name="remove_sentence(_$sid_)"
>remove_sentence( $sid )</a></h2>

<p>Removes the sentence with the id $sid and all assertions derived from it. As a side effect, if the paragraph to which it belongs has no remaining sentences in the EKB, that paragraph is removed as well.</p>

<h2><a class='u'
name="get_attr(_$attribute_)"
>get_attr( $attribute )</a></h2>

<p>Returns value of the EKB attribute.</p>

<h2><a class='u'
name="set_attr(_$attribute,_$value_)"
>set_attr( $attribute, $value )</a></h2>

<p>Returns value of the EKB attribute to the given value.</p>

<h2><a class='u'
name="get_docs(_)"
>get_docs( )</a></h2>

<p>Returns the list of document nodes.</p>

<h2><a class='u'
name="get_doc(_$docid_)"
>get_doc( $docid )</a></h2>

<p>Returns the document node with the given document ID.</p>

<h2><a class='u'
name="set_docid_(_$docid,_$new_docid_)"
>set_docid ( $docid, $new_docid )</a></h2>

<p>Replaces the document ID.</p>

<h2><a class='u'
name="get_paragraphs(_$docid_)"
>get_paragraphs( $docid )</a></h2>

<p>Returns the list of paragraph nodes. If the optional argument is given, the list is restricted to the paragraphs with the given document ID.</p>

<h2><a class='u'
name="get_paragraph(_$pid_)"
>get_paragraph( $pid )</a></h2>

<p>Returns the paragraph node with the given paragraph ID.</p>

<h2><a class='u'
name="get_sentences(_$pid_)"
>get_sentences( $pid )</a></h2>

<p>Returns the list of sentence nodes. If the optional argument is given, the list is restricted to the sentences with the given paragraph ID.</p>

<h2><a class='u'
name="get_sentence(_$sid_)"
>get_sentence( $sid )</a></h2>

<p>Returns the sentence node with the given sentence ID.</p>

<h2><a class='u'
name="get_assertions(_$atype,_$attributes_)"
>get_assertions( $atype, $attributes )</a></h2>

<p>Returns a list of assertions. All arguments are optional.</p>

<p>If no arguments are present, returns all EKB assertions. If the $atype argument is specified, returns all EKB assertions of the given type. If the $attributes argument is specified, it must be a reference to a hash of attribute-value pairs; in this case, the resulting list is restricted to those assertions that have all those attributes, with the given values.</p>

<h2><a class='u'
name="get_assertion(_$id,_$atype,_$attributes_)"
>get_assertion( $id, $atype, $attributes )</a></h2>

<p>Returns the EKB assertion with the given id. Optionally, a type may be specified to get only the assertion of that type, if one exists. Returns <code>undef</code> if a matching assertion cannot be found.</p>

<p>...</p>

<h2><a class='u'
name="find_members_rec(_$id,_$op_list_)"
>find_members_rec( $id, $op_list )</a></h2>

<p>Find recursively the members of an aggregate term with the given identifier.</p>

<p>If present, $op_list must be a reference to a list of allowable operators. If not present, all operators are allowed.</p>

<p>If $id is the identifier of a term that is not an aggregate, this method will return just the term itself.</p>

<h2><a class='u'
name="add_assertion(_$node_)"
>add_assertion( $node )</a></h2>

<p>Adds an XML representation of an assertion to the EKB document.</p>

<h2><a class='u'
name="remove_assertion(_$a_)"
>remove_assertion( $a )</a></h2>

<p>Removes an XML representation of an assertion from the EKB document.</p>

<h2><a class='u'
name="derive_assertion(_$id,_$atype_)"
>derive_assertion( $id, $atype )</a></h2>

<p>Creates a new assertion based on the one with the given ID.</p>

<p>The new assertion will be a shallow copy of the old one, where only text-related attributes and properties are preserved. Specifically:</p>

<dl>
<dt><a 
>a) the new assertion will have the same type as the old one, unless $atype is specified, in which case the new assertion will be of the type $atype;</a></dt>

<dd>
<dt><a name="b)_text-related_attributes_(paragraph,_uttnum,_start_and_end)_are_copied;_and"
>b) text-related attributes (<code>paragraph</code>, <code>uttnum</code>, <code>start</code> and <code>end</code>) are copied; and</a></dt>

<dd>
<dt><a name="c)_the_only_property_copied_is_text,_if_it_exists."
>c) the only property copied is <code>text</code>, if it exists.</a></dt>
</dl>

<p>If successful, returns the newly created assertion. If an assertion with the given ID doesn&#39;t exist, returns <code>undef</code>.</p>

<h2><a class='u'
name="clone_assertion(_$a,_$attributes_)"
>clone_assertion( $a, $attributes )</a></h2>

<p>Creates a new assertion as a clone of $a.</p>

<p>The new assertion will be a deep copy of the old, cleaned up and with a new ID. The derivational history is kept via the <code>refid</code> attribute.</p>

<p>If the optional $attributes argument is given, the new assertion&#39;s attributes are set accordingly. Currently the only attribute supported is <code>rule</code>. This behavior might change to support an unrestricted list of attribute-value pairs.</p>

<p>If successful, returns the newly created assertion. If an assertion with the given ID doesn&#39;t exist, returns <code>undef</code>.</p>

<h2><a class='u'
name="clean_assertion(_$assertion,_$opts_)"
>clean_assertion( $assertion, $opts )</a></h2>

<p>Removes unnecessary attributes and content from the assertion. Use { keep_lisp =&#62; } to keep lisp representation.</p>

<h2><a class='u'
name="make_assertion(_$atype,_$attributes,_@properties_)"
>make_assertion( $atype, $attributes, @properties )</a></h2>

<p>Creates and returns an assertion.</p>

<p>This is basically just an OO version of <a href="#make_node(_%24name%2C_%24attributes%2C_%40children_)" class="podlinkpod"
>make_node()</a>, with an additional check that $atype is a proper assertion type.</p>

<p>The optional @content argument specifies the attributes and the slots of the assertion. It is passsed directly to <a href="#make_node(_%24name%2C_%24attributes%2C_%40children_)" class="podlinkpod"
>make_node()</a>. Assertion attributes correspond directly to the XML element&#39;s attributes; assertion properties must be XML nodes and they will be added as children in the assertion&#39;s XML Element representation.</p>

<p>If an id for the assertion is not specified in $attributes, a new id is generated for the assertion.</p>

<h2><a class='u'
name="modify_assertion(_$a,_$attributes,_@properties_)"
>modify_assertion( $a, $attributes, @properties )</a></h2>

<p>Modifies an assertion by adding/replacing attributes and properties.</p>

<p>New attributes are simply added. Values of existing attributes are generally replaced, with two exceptions: <code>refid</code> and <code>rule</code> attributes are cummulative, so they&#39;re always added on rather than replaced. Moreover, the value of <code>refid</code> is a reference to a list, so multiple reference IDs can be added on simultaneously (all regular attributes should have scalar values).</p>

<p>New properties are simply added. Generally, if a property already exists with the same name, it will be deleted and a warning will be issued. However, <code>arg</code> properties are treated cumulatively (even when the <code>role</code> value is the same!).</p>

<p>If <code>start</code>, <code>end</code> and <code>pid</code> attributes are set, the <code>text</code> property is calculated (if given in @properties, it will be overwritten).</p>

<p>See: <a>append_to_attribute()</a></p>

<h2><a class='u'
name="make_complex_term(_$ids,_$attributes,_@properties_)"
>make_complex_term( $ids, $attributes, @properties )</a></h2>

<p>Makes a macomolecular complex term with component ids given in the list referenced by $ids.</p>

<p>The $ids argument is required (but can be a reference to an empty list). The other arguments are optional.</p>

<p>Examples:</p>

<p>my $c = make_complex_term([$term_id1, $term_id2], {rule =&#62; &#39;MY_RULE&#39;});</p>

<h2><a class='u'
name="make_complex_name(_$components_)"
>make_complex_name( $components )</a></h2>

<p>Makes a name for a macomolecular complex term from the names of its components. If any component doesn&#39;t have a name, it returns just the string &#34;COMPLEX&#34;.</p>

<p>TODO: This function ought to be called automatically by EKB::make_complex_term().</p>

<h2><a class='u'
name="make_conjoined_event(_$ids,_$operator,_$attributes,_@properties_)"
>make_conjoined_event( $ids, $operator, $attributes, @properties )</a></h2>

<p>Makes a conjoined event with member ids given in the list referenced by $ids, joined by $operator.</p>

<p>The $ids argument is required and has to be a reference to a (possibly empty) list of ids. The $operator argument is required and must be a string. The other arguments are optional.</p>

<p>Examples:</p>

<p>my $a = make_conjoined_event([$term_id1, $term_id2], &#39;AND&#39;, {rule =&#62; &#39;MY_RULE&#39;});</p>

<h2><a class='u'
name="make_aggregate_term(_$ids,_$operator,_$attributes,_@properties_)"
>make_aggregate_term( $ids, $operator, $attributes, @properties )</a></h2>

<p>Makes an aggregate term with member ids given in the list referenced by $ids, joined by $operator.</p>

<p>The $ids argument is required and has to be a reference to a (possibly empty) list of ids. The $operator argument is required and must be a string. The other arguments are optional.</p>

<p>Examples:</p>

<p>my $a = make_aggregate_term([$term_id1, $term_id2], &#39;AND&#39;, {rule =&#62; &#39;MY_RULE&#39;});</p>

<h2><a class='u'
name="add_assertion_r(_$atype,_%args_)"
>add_assertion_r( $atype, %args )</a></h2>

<p>Creates and adds an assertion of the given type to the EKB document.</p>

<p>%args is a hash specifying the contents of the assertion. It may contain a <code>refs</code> key pointing to a list of reference assertions. The new assertion is then created as a derivation of the first reference assertion, the effect being that some of the content is copied from there. The rest of the reference assertions are only used as mentions in a new attribute called <code>refid</code>.</p>

<p>Returns the id of the new assertion on success, and <code>undef</code> on failure.</p>

<p>NOTE: This function uses a different convention than others for identifying attributes and properties; probably should be changed to avoid confusion.</p>

<p>OBSOLETE: use infer_assertion instead!</p>

<h2><a class='u'
name="infer_assertion(_$atype,_$attributes,_@properties_)"
>infer_assertion( $atype, $attributes, @properties )</a></h2>

<p>Creates and adds an assertion of the given type to the EKB document.</p>

<p>If the <code>refid</code> attribute is set in $attributes, the new assertion is derived from the assertion with the first id.</p>

<p>Returns the id of the new assertion on success, and <code>undef</code> on failure.</p>

<h2><a class='u'
name="add_term_r(_%args_)"
>add_term_r( %args )</a></h2>

<p>Creates and adds a TERM assertion to the EKB.</p>

<p>This is just a wrapper around <a href="#add_assertion_r(_%24atype%2C_%25args_)" class="podlinkpod"
>add_assertion_r()</a>.</p>

<p>OBSOLETE</p>

<h2><a class='u'
name="add_event_r(_%args_)"
>add_event_r( %args )</a></h2>

<p>Creates and adds an EVENT assertion to the EKB.</p>

<p>Returns the id of the inferred event.</p>

<p>This is mostly a wrapper around <a href="#add_assertion_r(_%24atype%2C_%25args_)" class="podlinkpod"
>add_assertion_r()</a>.</p>

<p>OBSOLETE</p>

<h2><a class='u'
name="causes(_$fid,_$oid,_$attrs_)"
>causes( $fid, $oid, $attrs )</a></h2>

<p>Infers a CC assertion, setting the factor and the outcome to $fid and $oid, respectively.</p>

<p>If given, $attrs specifies additional attributes to be set for the new assertion.</p>

<p>Returns the id of the inferred event.</p>

<p>See <a href="http://search.cpan.org/perldoc?infer_assertion(_%24atype%2C_%24attributes%2C_%40properties_)" class="podlinkpod"
>infer_assertion(_$atype,_$attributes,_@properties_)</a></p>

<h2><a class='u'
name="increases(_$id,_$attrs_)"
>increases( $id, $attrs )</a></h2>

<p>Infers an EVENT assertion representing a (quantitative) increase of whatever is represented by the assertion with the id $id.</p>

<p>If given, $attrs specifies additional attributes to be set for the new assertion.</p>

<p>Returns the id of the inferred event.</p>

<p>See <a href="http://search.cpan.org/perldoc?add_event_r" class="podlinkpod"
>add_event_r</a></p>

<h2><a class='u'
name="decreases(_$id,_$attrs_)"
>decreases( $id, $attrs )</a></h2>

<p>Infers an EVENT assertion representing a (quantitative) decrease of whatever is represented by the assertion with the id $id.</p>

<p>If given, $attrs specifies additional attributes to be set for the new assertion.</p>

<p>Returns the id of the inferred event.</p>

<p>See <a href="http://search.cpan.org/perldoc?add_event_r" class="podlinkpod"
>add_event_r</a></p>

<h2><a class='u'
name="add_arg(_$a,_$role,_$id,_$pos_)"
>add_arg( $a, $role, $id, $pos )</a></h2>

<p>Creates an argument element with the given ID and role name, and adds it as a child to $a, which must be a relational assertion.</p>

<p>See <a href="#make_arg(_%24role%2C_%24id%2C_%24pos_)" class="podlinkpod"
>make_arg()</a> for the meaning of the arguments.</p>

<p>If the optional $pos argument is given, the new argument is inserted so that all arguments are in proper order (assuming other arguments have positional information).</p>

<h2><a class='u'
name="add_feature(_$a,_$feature,_$value_)"
>add_feature( $a, $feature, $value )</a></h2>

<p>Adds a <code>feature</code> node to an assertion&#39;s list of features.</p>

<p>For simple features, $value is a scalar (eg, &#39;TRUE&#39;). Other features are defined by their attributes, in which case $value is a reference to a hashlist of attribute-value pairs.</p>

<p>Returns the feature element just created.</p>

<p>Examples:</p>

<pre>  $ekb-&#62;add_feature($a, &#39;active&#39; =&#62; &#39;TRUE&#39;);
  $ekb-&#62;add_feature($a, &#39;location&#39; =&#62; { id =&#62; &#39;T12345&#39; });
  $ekb-&#62;add_feature($a, &#39;bound-to&#39; =&#62; { id =&#62; &#39;T12346&#39;, event =&#62; &#39;E23456&#39; });
  $ekb-&#62;add_feature($a, &#39;ptm&#39; =&#62; { type =&#62; &#39;ONT::PHOSPHORYLATION&#39;, event =&#62; &#39;E23457&#39; });
  $ekb-&#62;add_feature($a, &#39;inevent&#39; =&#62; { id =&#62; &#39;E23458&#39; });</pre>

<h2><a class='u'
name="add_notfeature(_$a,_$feature,_$value_)"
>add_notfeature( $a, $feature, $value )</a></h2>

<p>Adds a <code>feature</code> node to an assertion&#39;s list of not-features.</p>

<p>For simple features, $value is a scalar (eg, &#39;TRUE&#39;). Other features are defined by their attributes, in which case $value is a reference to a hashlist of attribute-value pairs.</p>

<p>Examples:</p>

<pre>  $ekb-&#62;add_notfeature($a, &#39;active&#39; =&#62; &#39;TRUE&#39;);
  $ekb-&#62;add_notfeature($a, &#39;location&#39; =&#62; { id =&#62; &#39;T12345&#39; });
  $ekb-&#62;add_notfeature($a, &#39;bound-to&#39; =&#62; { id =&#62; &#39;T12346&#39;, event =&#62; &#39;E23456&#39; });
  $ekb-&#62;add_notfeature($a, &#39;ptm&#39; =&#62; { type =&#62; &#39;ONT::PHOSPHORYLATION&#39;, event =&#62; &#39;E23457&#39; });</pre>

<h2><a class='u'
name="new_id(_$prefix,_$length_)"
>new_id( $prefix, $length )</a></h2>

<p>Generates a new id.</p>

<p>Both parameters are optional. The default prefix is &#34;R&#34;, and the default length is 6.</p>

<p>The id generated will be the concatenation of $prefix and a number with $length digits. Currently, there is no way to change this format.</p>

<p>This function guarantees that the id is unique by always incrementing the number portion of the id.</p>

<h1><a class='u'
name="UTILITY_FUNCTIONS"
>UTILITY FUNCTIONS</a></h1>

<p>This package implements and exports a number of utility functions, many of which are operations on XML nodes. These are not part of the EKB OO interface; they could be thought of as <a href="http://search.cpan.org/perldoc?XML%3A%3ALibXML%3A%3ANode" class="podlinkpod"
>XML::LibXML::Node</a> extensions performing EKB-related functions.</p>

<h2><a class='u'
name="get_assertion_type(_$a_)"
>get_assertion_type( $a )</a></h2>

<p>Returns the type of assertion $a, or <code>undef</code> if $a is not an assertion.</p>

<h2><a class='u'
name="is_assertion_type(_$atype_)"
>is_assertion_type( $atype )</a></h2>

<p>Returns true if $atype is a valid assertion type, and false otherwise.</p>

<h2><a class='u'
name="is_relation(_$a_)"
>is_relation( $a )</a></h2>

<p>Returns 1 iff $a is a relational assertion.</p>

<h2><a class='u'
name="assertion_args(_$a,_$filter_)"
>assertion_args( $a, $filter )</a></h2>

<p>Returns list of (main) arguments for relational assertion $a.</p>

<p>If $a is not a relational assertion, it returns an empty list.</p>

<p>If the optional $filter argument is given, it must be an XPath predicate. The result will be only those arguments matching the filter.</p>

<h2><a class='u'
name="assertion_xargs(_$a_)"
>assertion_xargs( $a )</a></h2>

<p>Returns list of satellite (&#39;extra&#39;) arguments for relational assertion $a.</p>

<p>If $a is not a relational assertion, it returns an empty list.</p>

<h2><a class='u'
name="get_child_node(_$node,_$name_)"
>get_child_node( $node, $name )</a></h2>

<p>Returns the first child of <code>node</code> with given tag name.</p>

<h2><a class='u'
name="get_children_by_name(_$node,_$name_)"
>get_children_by_name( $node, $name )</a></h2>

<p>Returns all children of <code>node</code> with given tag name.</p>

<h2><a class='u'
name="get_slot_value(_$node,_$name_)"
>get_slot_value( $node, $name )</a></h2>

<p>Gets the value (text content) of $node&#39;s slot with the name $name.</p>

<h2><a class='u'
name="set_slot_value(_$node,_$name,_$value_)"
>set_slot_value( $node, $name, $value )</a></h2>

<p>Sets value (text content) of a slot.</p>

<h2><a class='u'
name="make_arg(_$role,_$id,_$pos_)"
>make_arg( $role, $id, $pos )</a></h2>

<p>Makes an argument element (for relational assertions) with the given ID and role name.</p>

<p>The optional <code>pos</code> argument specifies the argument position (i.e., &#34;arg1&#34;, &#34;arg2&#34;, etc.). It is kept only for historical reasons; generally it should not be used.</p>

<h2><a class='u'
name="make_predicate(_$type_)"
>make_predicate( $type )</a></h2>

<p>Makes a <code>predicate</code> node with a given type (specifically, an ont-type).</p>

<p>FIXME: A predicate frame can also have a text slot!</p>

<h2><a class='u'
name="make_slot_node(_$pname,_$pvalue_)"
>make_slot_node( $pname, $pvalue )</a></h2>

<p>Makes a slot node with the given property name and value.</p>

<p>A slot node has the form <code>&#60;pname&#62;pvalue&#60;/pname&#62;</code>. More complex property nodes (with attributes and/or children) should be created using <a href="#make_node(_%24name%2C_%24attributes%2C_%40children_)" class="podlinkpod"
>make_node()</a>.</p>

<p>TODO: rename to make_slot</p>

<h2><a class='u'
name="make_slot_nodes(_$pname1_=&#62;_$pvalue1,_..._)"
>make_slot_nodes( $pname1 =&#62; $pvalue1, ... )</a></h2>

<p>Makes a list of slot nodes with the given names and content.</p>

<p>See <a href="#make_slot_node(_%24pname%2C_%24pvalue_)" class="podlinkpod"
>make_slot_node()</a>.</p>

<p>TODO: rename to make_slots</p>

<h2><a class='u'
name="make_components(_@ids_)"
>make_components( @ids )</a></h2>

<p>Creates a components property and returns it.</p>

<p>If the list of ids is empty, it will return <code>undef</code>.</p>

<h2><a class='u'
name="make_node(_$name,_$attributes,_@children_)"
>make_node( $name, $attributes, @children )</a></h2>

<p>Makes an XML element node with a given name, attributes and children.</p>

<p>The optional argument $attributes is a reference to a hash of attribute-value pairs; they are added as attributes of the new node. The optional argument @children must be a list of XML element nodes; they are added as children of the new node.</p>

<p>...</p>

<h2><a class='u'
name="set_attribute(_$node,_$attribute,_$value_)"
>set_attribute( $node, $attribute, $value )</a></h2>

<p>Sets or replaces the value of an attribute of a node.</p>

<p>Note: This only has effect if $value is defined! Use removeAttribute() to remove an attribute!</p>

<h2><a class='u'
name="set_attributes(_$node,_$attribute_=&#62;_$value,_..._)"
>set_attributes( $node, $attribute =&#62; $value, ... )</a></h2>

<p>Sets or replaces values for a set of node attributes.</p>

<h2><a class='u'
name="add_child(_$node,_$child)"
>add_child( $node, $child)</a></h2>

<p>Adds a child element to a node.</p>

<h2><a class='u'
name="add_children(_$node,_@children)"
>add_children( $node, @children)</a></h2>

<p>Adds a set of children elements to a node.</p>

<h1><a class='u'
name="BUGS"
>BUGS</a></h1>

<p>Probably.</p>

<h1><a class='u'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Lucian Galescu &#60;lgalescu@ihmc.us&#62;</p>

<h1><a class='u'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Copyright (C) 2017 by Lucian Galescu &#60;lgalescu@ihmc.us&#62;</p>

<p>This module is free software. You may redistribute it and/or modify it under the terms of the Artistic License 2.0.</p>

<p>This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</p>

<!-- end doc -->

</body></html>
