<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- Generated by ezml2html by George Ferguson -->
<html>
<head>
<title>AKRL: Abstract Knowledge Representation Language</title>
<link rel="stylesheet" href="ezml.css" type="text/css">
</head>
<body>
<h1 class="title">AKRL: Abstract Knowledge Representation Language</h1>
<h1 class="author">James Allen and George Ferguson</h1>
<h1 class="date">21 Oct 2004 (updated 7 Feb 2005)</h1>
<p>
Information in TRIPS is expressed in <b>AKRL</b>, the Abstract Knowledge
Representation Language.  This language serves as an interlingua
between the linguistic processing of the system and the back-end
reasoning systems, which vary from application to application.  AKRL
retains some aspects of natural language that must be handled by the
reasoning systems themselves, or handled by some preprocessing layer
before the main reasoners are invoked.
<p>
AKRL is a frame-like representation that describes objects defined
using a domain-specific ontology.  The types, roles, and values used
to describe the objects come from this ontology, and may vary from
application to application. We use ontology mapping rules to translate
the semantics of natural language to and from the target ontology. The
important point is that the AKRL syntax (the expressions described in
this document, including additional roles) remains the same across
domains. This syntax allows us to represent those aspects of meaning
necessary to support natural language interpretation and connect it to
task- and domain-specific reasoning.
<p>
<h2 class="section" id="S1">1 Terms</h2><p>
Terms in AKRL denote objects. Because there are several ways in which
objects might be created or identified from linguistic forms, AKRL's
notation for terms is differs somewhat from standard KR languages.
<p>
The basic pattern for terms in AKRL is:
<blockquote>
  <tt>(</tt><em>indicator token attribute value attribute value ....</em><tt>)</tt>
</blockquote>
<p>
The first element of a term is called the <b>indicator</b>, for it
indicates how to interpret the expression.  A very common indicator is
<tt>A</tt>, which indicates that the term should be defined as a new object
that meets the specification (in contrast to <tt>THE</tt>, which indicates
that the reasoner should be able to identify an existing object that
meets the specification). The <em>token</em> is the symbol being defined, and
the attribute-value pairs correspond to slot names and values in the
underlying ontology.
<p>
Thus given:
<pre class="code">
  (A V1 :instance-of ROBOT :color GREEN)
</pre>
a reasoner knows that <tt>V1</tt> denotes a new object that is a
green robot (more precisely, a robot whose color is green). Note that the
object that a reasoner creates does not have to be the symbol
<tt>V1</tt>, it can be any atom the KR desires. <tt>V1</tt> is
a placeholder created by discourse processing that is used to manage
the discourse state, and also is used to refer to this newly created
object in more complex AKRL expressions.  To support discourse
processing, it can be important for the reasoner to inform the
language processing components of the correspondence between its
symbols and the AKRL symbols (as described below).
<p>
In a typical interaction, the language processing components produce a
set of AKRL expressions that, when interpreted together represent the
appropriate knowledge.  For instance, the AKRL expression
corresponding to the phrase <em><q>a robot taller than 6 feet</q></em> might be
captured by the following expressions, where the object types, role
names, and role values are wholly dependent on the domain-specific
ontology (and would get produced by our ontology mappings):
<pre class="code">
  (A V1 :instance-of ROBOT :height H1)
  (A H1 :instance-of HEIGHT-QUANTITY :unit FEET :numb N1)
  (A N1 :instance-of NUMBER :min-value 6)
</pre>
<p>
For completeness, the complete list of indicators (further described
below) is:
<ul>
<li><tt>A</tt>: Indefinite reference
<li><tt>THE</tt>: Definite reference
<li><tt>KIND</tt>: Complex type expression
<li><tt>RELN</tt>: Relational entity, such as actions, events, and properties
<li><tt>QUANT</tt>: Quantified expression
</ul>
<p>
<h2 class="section" id="S2">2 Domain Ontologies and Representation</h2><p>
As described above, details of AKRL representations depend on the
domain-specific ontology and are produced from the logical form of
input sentences by mapping rules. A few comments are in order.
<p>
First, the example above might have come from input <em><q>a green
robot</q></em>:
<pre class="code">
  (A V2 :instance-of ROBOT :color GREEN)
</pre>
This assumes that the domain-specific ontology class <tt>ROBOT</tt> has an
attribute (slot) <tt>color</tt> whose value can be specified by the token
<tt>GREEN</tt>. But another representation might be more detailed, for
example:
<pre class="code">
  (A V2 :instance-of ROBOT :color C1)
  (THE C1 :instance-of COLOR-VALUE :units RGB :value (0 255 0))
</pre>
<p>
The logical extension of this representation is that we could
represent properties homogeneously:
<pre class="code">
  (A V2 :instance-of ROBOT :properties (P1))
  (RELN P1 :instance-of ROLE-VALUE :role COLOR-OF :object V2 :value GREEN)
</pre>
The <tt>RELN</tt> indicator will be described below. In general, we will try
to use slot names inline wherever possible rather than resorting to
explicitly-enumerated properties expressed as <tt>RELN</tt>s.
<p>
<h2 class="section" id="S3">3 Definite Reference</h2><p>
It would be great if discourse processing was able to fully identify
the referents of referential expressions, and the domain reasoners
could ignore such issues. But it is not hard to see that such a
technique is not possible in most domains. Reasoning and domain
specific knowledge must get involved in reference resolution. Thus
AKRL supports a definite description mechanisms using the indicator
<tt>THE</tt>. Thus the phrase <em><q>the green robot</q></em> would be
represented as:
<pre class="code">
  (THE V3 :instance-of ROBOT :color GREEN)
</pre>
A reasoner encountering this expression should attempt to identify an
existing green robot in the knowledge base. In simple cases, there is
a unique object that matches the description and is the one that the
speaker intended. In general, however, there might be multiple possible
referents and the reasoner would need some mechanism for deciding
which one is intended. As much as possible, the language system will
provide information that should help the identification of the object
(from its reference resolution capabilities). There are special roles
that are defined that do this.
<p>
The easiest one to handle is <tt>:equals</tt>, which identifies a reasoner
constant that is the referent of the expression. For example:
<pre class="code">
  (THE V3 :instance-of ROBOT :color GREEN :equals KB656)
</pre>
In simple applications, reasoners can simply substitute the constant
<tt>KB656</tt>, which is already defined by the reasoner, for <tt>V1</tt> wherever
it appears.
<p>
In general, however, life isn't this simple and there is uncertainty
and ambiguity in the possible referents. Table 1 summarizes the
current set of roles that provide referential information. Note these
restrictions make a distinction between equality, where a new term is
constrained to be equal to a specific reasoner object, and coreference
(coref) where discourse knows that the new object is the same as a
previously defined AKRL object, but doesn't know any reasoner term
equivalent.
<table>
 <caption>Table 1: AKRL Referential roles</caption>
 <tr>
  <th>Relation</th>
  <th>Interpretation</th>
  <th>Example</th>
 </tr>
 <tr>
  <td><tt>:equals</tt></td>
  <td>The term is identical to the argument</td>
  <td>... <tt>:equals KR656</tt> ...</td>
 </tr>
 <tr>
  <td><tt>:coref</tt></td>
  <td>The term is co-referential with another term introduced
previously (whose corresponding KR constant is not known)</td>
  <td>... <tt>:coref V123</tt> ...</td>
 </tr>
 <tr>
  <td><tt>:one-of</tt></td>
  <td>The term is equal to one of the objects listed in the
argument</td>
  <td>... <tt>:one-of (KR656 KR777)</tt> ...</td>
 </tr>
 <tr>
  <td><tt>:not-one-of</tt></td>
  <td>The term is not one of the the objects listed in the
argument</td>
  <td>... <tt>:not-one-of (KR656 KR777)</tt> ...</td>
 </tr>
</table>
<p>
<h2 class="section" id="S4">4 Sets</h2><p>
Sets are ubiquitous in the content of natural language.  Since
knowledge representation systems handle sets in many different ways,
AKRL has some explicit mechanisms for defining set objects that will
need to be translated into the target reasoner representation.  Set
objects are indicated by an object of the special type <tt>SET</tt>, and have
several special roles that are useful for the reasoning system:
<ul>
<li><tt>:element-type</tt>:
The type that characterizes each element of the set
<li><tt>:size</tt>:
The size of the set
<li><tt>:members</tt>
Known members of the set (and if the number here equals the size of 
the set, then it is the complete set)
<li><tt>:not-members</tt>
Objects known not to be in the set (e.g., <em><q>every person except 
John</q></em>)
<li><tt>:subset-of</tt>
The set is a subset of the indicated set
</ul>
<p>
For example, the phrase <em><q>the three robots</q></em> might end up as
follows (if the ontology mappings are defined appropriately):
<pre class="code">
  (THE V40 :instance-of SET :element-type ROBOT :size 3)
</pre>
The phrase <em><q>three robots</q></em> would be the same except the
indicator would be <tt>A</tt> rather than <tt>THE</tt>.
<p>
If the type is more complex, as in <em><q>the green robots</q></em>, then it
would be defined with an AKRL <tt>KIND</tt> expression, which
produces a complex type description:
<pre class="code">
  (THE V41 :instance-of SET :element-type V42)
  (KIND V42 :instance-of ROBOT :color GREEN)
</pre>
<p>
A specific set construction uses <em>of</em>, as in <em><q>three of the
trucks</q></em>. This is interpreted as specifying a subset of some reference
set specified using the <tt>:subset-of</tt> role:
<pre class="code">
  (A V43 :instance-of SET :size 3 :subset-of V44)
  (THE V44 :instance-of SET :element-type TRUCK)
</pre>
<p>
Finally, if the language system knows the referent, or restrictions on
the referents, then they are expressed using the referential roles
defined in the previous section. The set values are expressed as
lists.  For example, the interpretation of <em><q>the robots</q></em>, when the
language system knows from context that this refers to robots <tt>R1</tt> and
<tt>R2</tt>, would be:
<pre class="code">
  (THE V45 :instance-of SET :element-type ROBOT :equals (R1 R2))
</pre>
<p>
<h2 class="section" id="S5">5 Relations (actions and properties)</h2><p>
Because knowledge representations differ markedly in how actions,
events, and properties are represented, AKRL does not attempt to
distinguish these cases, nor commit to any ontological stance (e.g.,
that the occurance of an event entails that there exists an object
that is the event). The indicator used for these relational statements
is <tt>RELN</tt>. Thus, assuming the appropriate ontology mapping
rules, the content of the assertion <em><q>Three robots arrived</q></em>
might be:
<pre class="code">
  (RELN V50 :instance-of ARRIVE :theme V51)
  (A V51 :instance-of SET :element-type ROBOT :size 3)
</pre>
The type <tt>ARRIVE</tt> and its role <tt>:theme</tt> (as well as the type <tt>ROBOT</tt>)
all come from the domain ontology.
<p>
<div class="aside">
<b>Note to KR hackers:</b>
In some representations, <tt>V50</tt> might correspond to a newly
defined object in the representation, in others the event might be
mapped to a formula or might be ignored.
For instance, one KR might map the above expression to something like:
<pre class="code">
Exists V50 ,V51 . Occurs(V50) &amp; Type(V50, Arrive) &amp; theme(V150, V51) &amp;
    Set(V51) &amp; (All x . in(x, V51) =&gt; Type(x, Robot)) &amp; |V51|=3
</pre>
creating a new object for the arrival event. Another might just map
the <tt>RELN</tt> clause to a predicate, and produce something like:
<pre class="code">
Exists V51. Arrive(V51) &amp; Set(V51) &amp; ...
</pre>
There are almost as many treatments of this as there are knowledge
representations.
</div>
<p>
Generally speaking, terms described using <tt>RELN</tt> correspond to
reified sentential or propositional entities. Thus the representation
of <em><q>John believes that the truck is green</q></em> would be represented as
something like:
<pre class="code">
  (RELN V52 :instance-of BELIEVE :agent V53 :belief V54)
  (THE V53 :instance-of PERSON :name John)
  (RELN V54 :instance-of ROLE-VALUE :role COLOR-OF :object V55 :value V56)
  (THE V56 :instance-of TRUCK)
  (THE V57 :instance-of COLOR :equals GREEN)
</pre>
The types <tt>BELIEVE</tt>, <tt>PERSON</tt>, <tt>TRUCK</tt>, <tt>COLOR</tt>, and even <tt>COLOR-OF</tt>
(a reified property or slot name) and their roles come from the domain
ontology. The example assumes that the word <em>green</em> maps directly to
the domain term <tt>GREEN</tt>. The formation of this representation from the
linguistic form would be handled by the ontology mapping rules.
<p>
<h2 class="section" id="S6">6 Quantifiers</h2><p>
Quantified expressions are extremely complex in natural language, and
only the simplest cases are handled adequately here. AKRL currently
does not provide any scoping information (and it is not clear whether
it will in the long term as many quantifier scoping decisions depend
on using reasoning).
<p>
AKRL provides two mechanisms for modeling quantified information,
depending on whether the quantifier can be interpretated as
specifying the size of a set or not. Those that have a set size
interpretation require a plural head noun (e.g., <em><q>several trucks</q></em>) and
cannot take a numeric modifier (e.g., you can't say <em><q>several three
trucks</q></em>).  The other mechanism treats quantifiers similar to a
quantifier in first order logic. We'll call these two the <b>quantity
quantifiers</b> and the <b>logical quantifiers</b>.
<p>
<h2 class="subsection" id="S6.1">6.1 Quantity Quantifiers</h2><p>
The typical quantity quantifiers include <em>several</em>, <em>many</em>, <em>a few</em>,
<em>not many</em>, and so on. These are interpreted as sets with the quantifier as the
<tt>:size</tt> of the set.  For example, <em><q>several trucks</q></em> would map to
an AKRL expression such as:
<pre class="code">
  (A V60 :instance-of SET :element-type TRUCK :size SEVERAL)
</pre>
<p>
In more complex expressions, the value is a number characterized by
the quantifier. For example, the phrase <em><q>at least three trucks</q></em>
might map to the following expression:
<pre class="code">
  (A V61 :instance-of SET :element-type TRUCK :size V62)
  (A V62 :instance-of NUMBER :min-value 3)
</pre>
The details would depend on the underlying ontologies representation
of numbers and numerical constraints.
<p>
Finally, an <em>of</em> construction describes a subset of a definite set, as
in <em><q>several of the trucks</q></em>:
<pre class="code">
  (A V63 :instance-of SET :element-type TRUCK :size SEVERAL :subset-of V64)
  (THE V64 :instance-of SET :element-type TRUCK)
</pre>
<p>
<h2 class="subsection" id="S6.2">6.2 Logical Quantifiers</h2><p>
The logical quantifiers are a complicated bunch. The first group of
logical quantifiers include <em>every</em>, <em>each</em>, <em>no</em>, and <em>none</em>. The
indicator for these is <tt>QUANT</tt>, and the specific quantifier appears as
the role <tt>:quantifier</tt>. For example, <em><q>every truck</q></em> would be
represented as follows (again assuming the appropriate ontology
mappings):
<pre class="code">
  (QUANT V70 :instance-of TRUCK :quantifier EVERY)
</pre>
<p>
Sometimes the set over which the quantification occurs is explicit or
can be recovered from context. In that case, it is expressed using the
<tt>:domain</tt> role. For example, <em><q>every one of the trucks</q></em> would be
represented as:
<pre class="code">
  (QUANT V71 :instance-of TRUCK :quantifier EVERY :domain V72)
  (THE V73 :instance-of SET :equals KR888)
</pre>
<p>
Note that negative quantifiers expressly indicate that there is no
object that meets the description. For instance, the phrase <em><q>no truck</q></em>
would be represented as:
<pre class="code">
  (QUANT V74 :instance-of TRUCK :quantifier NO)
</pre>
<p>
<h2 class="subsubsection" id="S6.2.1">6.2.1 All</h2><p>
The quantifier <em>all</em> acts like the quantifiers above except that it
always specifies a <tt>:domain</tt>, which is specified by a fully formed NP as
its complement. The simplest case is expressed as a plural head noun,
as in <em><q>all trucks</q></em>:
<pre class="code">
  (QUANT V80 :quan ALL :instance-of TRUCK :domain D1)
  (A D1 :instance-of SET :element-type TRUCK)
</pre>
<p>
The definite phrase <em><q>all the trucks</q></em> would have a definite domain:
<pre class="code">
  (QUANT V81 :quan ALL :instance-of TRUCK :domain D2)
  (THE D2 :instance-of SET :element-type TRUCK)
</pre>
<p>
We also can have expressions like <em><q>all the red trucks</q></em> or <em><q>all three
trucks</q></em>. The latter would be expressed as something like:
<pre class="code">
  (QUANT V82 :quantifier ALL :instance-of TRUCK :domain D3)
  (THE D3 :instance-of SET :element-type TRUCK :size 3)
</pre>
<p>
Note that the word <em>both</em> is treated as <em>all two</em> (a definite domain
of size two), as in <em><q>both trucks</q></em>:
<pre class="code">
  (QUANT V83 :quantifier ALL :instance-of TRUCK :domain D4)
  (THE D4 :instance-of SET :element-type TRUCK :size 2)
</pre>
<p>
<h2 class="subsubsection" id="S6.2.2">6.2.2 Some</h2><p>
The quantifier <em>some</em> is complex in that it takes both singular and
plural forms, as in <em>some truck</em> and <em>some trucks</em>.
<p>
The singular case we treat as a simple indefinite, e.g., <em><q>some truck</q></em>:
<pre class="code">
  (A V90 :instance-of TRUCK)
</pre>
There is (arguably) a slight difference between <em><q>a truck</q></em> and <em><q>some
truck</q></em>, but we feel that the distinction is unlikely to be important
in practice.
<p>
The plural case is treated as a standard quantity quantifier. Thus,
<em><q>some trucks</q></em>:
<pre class="code">
  (A V91 :instance-of SET :element-type TRUCK :size SOME)
</pre>
and <em><q>some of the trucks</q></em>:
<pre class="code">
  (A V92 :instance-of SET :instance-of TRUCK :size SOME :subset-of V93)
  (THE V93 :instance-of SET :element-type TRUCK)
</pre>
</body>
</html>
